// Notes
// Chapter5 Higher-order Functions
function repeat(n, action) {
    for(let i = 0; i < n; i++) {
        action(i);
    }
}

let labels = [];
repeat(5, i => {
    labels.push(`Unit ${i + 1}`);
});

// Functions that create new functions
function greaterThan(n) {
    return m => m > n;
}

let greaterThan10 = greaterThan(10);
console.log(greaterThan10(11));

// Functions that change other functions
function noisy(f) {
    return (...args) => {
        console.log('calling with', args);
        let result = f(...args);
        console.log('called with', args, ', returned', result);
        return result;
    };
}

noisy(Math.min)(3, 2, 1);
// calling with [ 3, 2, 1 ]
// called with [ 3, 2, 1 ] , returned 1
// 1

// Functions that provide new types of control flow
function unless(test, then) {
    if(!test) then();
}

repeat(3, n => {
    unless(n % 2 == 1, () => {
        console.log(n, 'is even');
    });
});

// 0 'is even'
// 2 'is even'

/*****
SCRIPTS DATA SET
*****/

// Example filter
function filter(array, test) {
    let passed = [];
    for(let element of array) {
        if(test(element)) {
            passed.push(element);
        }
    }
    return passed;
}

console.log(filter(SCRIPTS, script => script.living));
console.log(SCRIPTS.filter(s => s.direction == 'ttb'));

// Example map
function map(array, transform) {
    let mapped = [];
    for(let element of array) {
        mapped.push(transform(element));
    }
    return mapped;
}

let rtlScripts = SCRIPTS.filter(s => s.direction == 'rtl');
console.log(map(rtlScripts, s => s.name));

[ 'Adlam',
  'Arabic',
  'Imperial Aramaic',
  'Avestan',
  'Cypriot',
  'Hatran',
  'Hebrew',
  'Old Hungarian',
  'Kharoshthi',
  'Lydian',
  'Mandaic',
  'Manichaean',
  'Mende Kikakui',
  'Meroitic Cursive',
  'Meroitic Hieroglyphs',
  'Old North Arabian',
  'Nabataean',
  'Nko',
  'Old Turkic',
  'Palmyrene',
  'Inscriptional Pahlavi',
  'Psalter Pahlavi',
  'Phoenician',
  'Inscriptional Parthian',
  'Samaritan',
  'Old South Arabian',
  'Syriac',
  'Thaana' ]

// Example reduce
function reduce(array, combine, start) {
    let current = start;
    for(let element of array) {
        current = combine(current, element);
    }
    return current;
}
console.log(reduce([1, 2, 3, 4], (a, b) => a + b, 0));
// 10

// To use reduce twice to find the script with the most characters, we can write:
function characterCount(script) {
    return script.ranges.reduce((count, [from, to]) => {
        return count + (to - from);
    }, 0);
}

console.log(SCRIPTS.reduce((a, b) => {
    return characterCount(a) < characterCount(b) ? b : a;
}));

// Find the average year of origin for living and dead scripts
function average(array) {
    return array.reduce((a, b) => a + b) / array.length;
}

console.log(Math.round(average(
    SCRIPTS.filter(s => s.living).map(s => s.year))));
console.log(Math.round(average(
    SCRIPTS.filter(s => !s.living).map(s => s.year))));

// Strings and character codes
function characterScript(code) {
    for(let script of SCRIPTS) {
        if(script.ranges.some(([from, to]) => {
            return code >= from && code < to;
        })) {
            return script;
        }
    }
    return null;
}

console.log(characterScript(121));

// Count characters that belong to each script
function countBy(items, groupName) {
    let counts = [];
    for(let item of items) {
        let name = groupName(item); // Where is this groupName function coming from?
        let known = counts.findIndex(c => c.name == name); // Not sure what's happening here either. Where is 'c'? Is it merely the name of each 'Item'?
        console.log(name);
        if(known == -1) {
            counts.push({name, count: 1});
        } else {
            counts[known].count++;
        }
    }
    return counts;
}

console.log(countBy([1, 2, 3, 4, 5], n => n > 2)); // Ok, groupName is an abstraction for a function that tests a condition or acts like a filter.

// Using countBy, we can write a function that tells us which scripts are used in a piece of text
function textScripts(text) {
    let scripts = countBy(text, char => {
        let script = characterScript(char.codePointAt(0));
        return script ? script.name : 'none';
    }).filter(({name}) => name != 'none');

    let total = scripts.reduce((n, {count}) => n + count, 0);
    if(total == 0) return 'No scripts found';

    return scripts.map(({name, count}) => {
        return `${Math.round(count * 100 / total)}% ${name}`;
    }).join(', ');
}

/*****
Excercises
*****/

/*
Flattening
Use the reduce method in combination with the concat method to “flatten” an array of arrays into a single array that has all the elements of the original arrays.
*/

let array1 = [['a', 'b', 'c'], ['d', 'e'], ['f', 'g', 'h']];
array1.reduce(item => {
    return item = a.concat(b);
});

function flattenArray(array) {
    array.reduce((a, b) => {
        a += a.concat(b);
        console.log(a);
    });
}

array1.reduce(function(accumulator = [], currentValue) {
    return accumulator.concat(currentValue)
});

//Solution
console.log(arrays.reduce((flat, current) => flat.concat(current), []));

/*
Your own loop
Write a higher-order function loop that provides something like a for loop statement. It takes a value, a test function, an update function, and a body function. Each iteration, it first runs the test function on the current loop value and stops if that returns false. Then it calls the body function, giving it the current value. Finally, it calls the update function to create a new value and starts from the beginning.
    When defining the function, you can use a regular loop to do the actual looping.
*/

function loop(value, test, update, body) {
    let result = [];
    for(element in array) {
        if(test(value)) {
            result.push(update(body(value)));
        }
    }
}

function loop(value, test, update, body) {
    let newValue;
    while(test(value)) {
        body(value);
        newValue = update(value);
        return value = newValue;
    }
}

// Solution
function loop(value, test, update, body) {
    for(value; test(value); value = update(value)) {
        body(value);
    }
}

/*
Everything
Analogous to the some method, arrays also have an every method. This one returns true when the given function returns true for every element in the array. In a way, some is a version of the || operator that acts on arrays, and every is like the && operator.

Implement every as a function that takes an array and a predicate function as parameters. Write two versions, one using a loop and one using the some method.
*/

// Not sure why the below code is not working as it should. One issue is that the results value is being mutated...
function every(array, predicateFunction) {
    for(let i = 0; i < array.length; i++) {
        let result = '';
        if(predicateFunction(array[i]) === false) {
            return result = false;
        } else {
            return result = true;
        }
    }
}

// Same logic but different point of return / exit for the true condition. Previously it was returning true / false after looping through any array element. Now it returns true only after end of the loop. Subtle shit.
function every(array, predicateFunction) {
    let result = true;
    for(let i = 0; i < array.length; i++) {
        if(predicateFunction(array[i]) === false) {
            return result = false;
        } else {
            result;
        }
    }
    return result;
}

// Solution
function every(array, predicate) {
    for (let element of array) {
        if (!predicate(element)) return false;
    }
    return true;
}

// This is obviously wrong, if(array.some(prdicate)) is true, every could also be true of false
function every(array, predicate) {
    if(!array.some(predicate)) {
        return false;
    } else {
        return true;
    }
}

// Solution
function every2(array, predicate) {
    return !array.some(element => console.log(!predicate(element)));
}

// Could not solve this problem. This is using some to check predicate for each element, but this requires some knowledge of how some function works internally, I thought that it only worked for arrays and did not think it could be used to loop over each element. Also how does it hold the value if last element happens to be true/false?
function every2(array, predicate) {
    return array.some(element => console.log(predicate(element)));
}

// Returns:
// every2([2, 4, 16], n => n < 10);
// true
// true
// false
// false
// So somehow some array iterates over the given array.

// Dominant writing direction
// Write a function that computes the dominant writing direction in a string of text. Remember that each script object has a direction property that can be "ltr" (left to right), "rtl" (right to left), or "ttb" (top to bottom).
//     The dominant direction is the direction of a majority of the characters that have a script associated with them. The characterScript and countBy func- tions defined earlier in the chapter are probably useful here.

function writingDirection(text) {
    let textArray = [];
    for (let char of text) {
        textArray.push()
    }
}

/*****
Interlude
*****/

// I'm not understanding this on some fundamental level. Need to get into it more.
// http://reactivex.io/learnrx/

// Projecting Arrays
// Applying a function to a value and creating a new value is called a projection. To project one array into another, we apply a projection function to each item in the array and collect the results in a new array.

// Exercise 3: Project an array of videos into an array of {id,title} pairs using forEach()
// For each video, add a projected {id, title} pair to the videoAndTitlePairs array.
function project() {
	var newReleases = [
		{
			"id": 70111470,
			"title": "Die Hard",
			"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
			"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
			"rating": [4.0],
			"bookmark": []
		},
		{
			"id": 654356453,
			"title": "Bad Boys",
			"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
			"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
			"rating": [5.0],
			"bookmark": [{ id: 432534, time: 65876586 }]
		},
		{
			"id": 65432445,
			"title": "The Chamber",
			"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
			"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
			"rating": [4.0],
			"bookmark": []
		},
		{
			"id": 675465,
			"title": "Fracture",
			"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
			"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
			"rating": [5.0],
			"bookmark": [{ id: 432534, time: 65876586 }]
		}
	],
	videoAndTitlePairs = [];

	// ------------ INSERT CODE HERE! -----------------------------------
	// Use forEach function to accumulate {id, title} pairs from each video.
	// Put the results into the videoAndTitlePairs array using the Array's
	// push() method. Example: videoAndTitlePairs.push(newItem);
	// ------------ INSERT CODE HERE! -----------------------------------

    // newReleases.forEach(function(video) {
    //     videoAndTitlePairs.push({'id': newReleases['id'], 'name': newReleases['name']});
    // });
    // This returns:
    // [ { id: undefined, name: undefined },
    //   { id: undefined, name: undefined },
    //   { id: undefined, name: undefined },
    //   { id: undefined, name: undefined } ]

    newReleases.forEach(function(video) {
	videoAndTitlePairs.push({ id: video.id, title: video.title });
    });
        return videoAndTitlePairs;
}

// All array projections share two operations in common:
// Traverse the source array
// Add each item's projected value to a new array
// Why not abstract away how these operations are carried out?

// Exercise 4: Implement map()
// To make projections easier, let's add a map() function to the Array type. Map accepts the projection function to be applied to each item in the source array, and returns the projected array.

Array.prototype.map = function(projectionFunction) {
    var results = [];
    this.forEach(function(itemInArray) {
	results.push(projectionFunction(itemInArray));
    });
    return results;
};

// JSON.stringify([1,2,3].map(function(x) { return x + 1; })) === '[2,3,4]'

// Exercise 5: Use map() to project an array of videos into an array of {id,title} pairs
// Let's repeat the exercise of collecting {id, title} pairs for each video in the newReleases array, but this time we'll use our map function.
function() {
	var newReleases = [
		{
			"id": 70111470,
			"title": "Die Hard",
			"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
			"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
			"rating": [4.0],
			"bookmark": []
		},
		{
			"id": 654356453,
			"title": "Bad Boys",
			"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
			"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
			"rating": [5.0],
			"bookmark": [{ id: 432534, time: 65876586 }]
		},
		{
			"id": 65432445,
			"title": "The Chamber",
			"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
			"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
			"rating": [4.0],
			"bookmark": []
		},
		{
			"id": 675465,
			"title": "Fracture",
			"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
			"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
			"rating": [5.0],
			"bookmark": [{ id: 432534, time: 65876586 }]
		}
	];
    // ------------ INSERT CODE HERE! -----------------------------------
    // Use map function to accumulate {id, title} pairs from each video.

    // return newReleases.map(video => {
    //     let newVideoItem = {};
    //     newVideoItem = {id: video.id, title: video.title};
    //     return newVideoItem;
    // });

    return newReleases.map(function(video) { return { id: video.id, title: video.title }; });

    // finish this expression!
    // ------------ INSERT CODE HERE! -----------------------------------
    }

// Notice that map allows us to specify what projection we want to apply to an array, but hides how the operation is carried out.

// Filtering Arrays
// Like projection, filtering an array is also a very common operation. To filter an array we apply a test to each item in the array and collect the items that pass into a new array.
// Exercise 6: Use forEach() to collect only those videos with a rating of 5.0
// Use forEach() to loop through the videos in the newReleases array and, if a video has a rating of 5.0, add it to the videos array.
var newReleases = [
    {
	"id": 70111470,
	"title": "Die Hard",
	"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
	"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
	"rating": 4.0,
	"bookmark": []
    },
    {
	"id": 654356453,
	"title": "Bad Boys",
	"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
	"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
	"rating": 5.0,
	"bookmark": [{ id: 432534, time: 65876586 }]
    },
    {
	"id": 65432445,
	"title": "The Chamber",
	"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
	"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
	"rating": 4.0,
	"bookmark": []
    },
    {
	"id": 675465,
	"title": "Fracture",
	"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
	"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
	"rating": 5.0,
	"bookmark": [{ id: 432534, time: 65876586 }]
    }
];

// Following code returns undefined, since the var 'topVideos' exists only within the inner scope of the forEach loop...
// Took a while to figure it out, it's subtle and confusing.
newReleases.forEach(video => {
    let topVideos = [];
    if(video.rating == 5) {
        topVideos.push(video);
        //console.log(topVideos);
    }
    return topVideos;
});

function getTopVideos(array) {
    let topVideos = [];
    array.forEach(video => {
        if(video.rating == 5) {
            topVideos.push(video);
        }
    });
    return topVideos;
}

// Notice that, like map(), every filter() operation shares some operations in common:
// Traverse the array
// Add objects that pass the test to a new array
// Why not abstract away how these operations are carried out?

// Exercise 7: Implement filter()
// To make filtering easier, let's add a filter() function to the Array type. The filter() function accepts a predicate. A predicate is a function that accepts an item in the array, and returns a boolean indicating whether the item should be retained in the new array.
Array.prototype.filter = function(predicateFunction) {
    var results = [];
    this.forEach(function(itemInArray) {
	// ------------ INSERT CODE HERE! ----------------------------
	// Apply the predicateFunction to each item in the array.
	// If the result is truthy, add the item to the results array.
	// Note: remember you can add items to the array using the array's
	// push() method.
	// ------------ INSERT CODE HERE! ----------------------------
        if(predicateFunction(itemInArray)) {
            results.push(itemInArray);
        }
    });

    return results;
};

// JSON.stringify([1,2,3].filter(function(x) { return x > 2})) === "[3]"
// Like map(), filter() lets us express what data we want without requiring us to specify how we want to collect the data.

// Query Data by Chaining Method Calls
// Exercise 8: Chain filter and map to collect the ids of videos that have a rating of 5.0
function chainMapAndFilter(array) {
    array.map((array.filter(video => video.rating == 5) => {
        return {id: video.id};
    }));
}

function chainMapAndFilter(array) {
    return array.filter(video => {return video.rating == 5}).
        map(video => {return video.id});
}

return newReleases.
    filter(function(video) {
	return video.rating === 5.0;
    }).
    map(function(video) {
	return video.id;
    });
}
